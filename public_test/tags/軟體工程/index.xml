<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>軟體工程 on AINEXT</title>
    <link>https://bnextmedia.github.io/AINEXT/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B/</link>
    <description>Recent content in 軟體工程 on AINEXT</description>
    <generator>Hugo</generator>
    <language>zh-TW</language>
    <lastBuildDate>Sun, 04 Jan 2026 12:00:00 +0800</lastBuildDate>
    <atom:link href="https://bnextmedia.github.io/AINEXT/tags/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vibe Coding 時代的技術債：寫程式像買房，你要會管理負債</title>
      <link>https://bnextmedia.github.io/AINEXT/posts/20260104-stanford-cs230-technical-debt-vibe-coding/</link>
      <pubDate>Sun, 04 Jan 2026 12:00:00 +0800</pubDate>
      <guid>https://bnextmedia.github.io/AINEXT/posts/20260104-stanford-cs230-technical-debt-vibe-coding/</guid>
      <description>&lt;div class=&#34;media-embed&#34;&gt;&#xA;  &lt;div class=&#34;video-container&#34;&gt;&#xA;    &lt;iframe &#xA;      src=&#34;https://www.youtube.com/embed/AuZoDsNmG_s&#34; &#xA;      allowfullscreen &#xA;      title=&#34;YouTube Video&#34;&#xA;      loading=&#34;lazy&#34;&#xA;    &gt;&lt;/iframe&gt;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;style&gt;&#xA;.media-embed {&#xA;  max-width: 100%;&#xA;  margin: 1rem 0;&#xA;}&#xA;&#xA;.video-container {&#xA;  position: relative;&#xA;  padding-bottom: 56.25%;&#xA;  height: 0;&#xA;  overflow: hidden;&#xA;}&#xA;&#xA;.video-container iframe {&#xA;  position: absolute;&#xA;  top: 0;&#xA;  left: 0;&#xA;  width: 100%;&#xA;  height: 100%;&#xA;  border: 0;&#xA;  border-radius: 12px;&#xA;}&#xA;&lt;/style&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;程式碼現在幾乎是免費的。打開 ChatGPT、Claude 或任何一個 AI 程式助手，用自然語言描述你要的功能，幾秒鐘後就會吐出一段可以執行的程式碼。這個能力在兩年前還是科幻小說，現在已經是很多工程師的日常。&lt;/p&gt;&#xA;&lt;p&gt;但免費的程式碼，代價其實很高。&lt;/p&gt;&#xA;&lt;p&gt;在史丹佛 CS230 的一堂職涯建議課上，業界專家 Laurence Moroney 用了一個很精準的比喻來解釋這件事：技術債（Technical Debt）。這個概念在軟體工程圈流傳已久，但在 Vibe Coding 時代，它變得比以往任何時候都更重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;為什麼這堂課值得聽&#34;&gt;為什麼這堂課值得聽？&lt;/h2&gt;&#xA;&lt;p&gt;先交代一下背景。這堂課發生在史丹佛，矽谷 AI 圈的核心基地。Google、OpenAI、Anthropic 的核心團隊裡充滿了史丹佛校友，很多產業前沿資訊都會先在這個圈子裡流通。&lt;/p&gt;&#xA;&lt;p&gt;主講者之一是吳恩達（Andrew Ng），Google Brain 創辦人、Coursera 共同創辦人、DeepLearning.AI 創辦人。他創立的 DeepLearning.AI 和 AI Fund 目前都在臺灣運作。另一位講者 Moroney 曾在 Google 負責 TensorFlow 全球推廣多年，現在在晶片公司 Arm 負責 AI 業務，是長期站在產業第一線的人。&lt;/p&gt;</description>
    </item>
    <item>
      <title>為什麼你的 AI Agent 總是不夠可靠？這個開發者訪談了 100 人後找到答案</title>
      <link>https://bnextmedia.github.io/AINEXT/posts/20251225-why-ai-agents-unreliable/</link>
      <pubDate>Thu, 25 Dec 2025 17:35:00 +0800</pubDate>
      <guid>https://bnextmedia.github.io/AINEXT/posts/20251225-why-ai-agents-unreliable/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本文整理自 Dex Horthy 在 AI Engineer 大會的演講。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;div class=&#34;media-embed&#34;&gt;&#xA;  &lt;div class=&#34;video-container&#34;&gt;&#xA;    &lt;iframe &#xA;      src=&#34;https://www.youtube.com/embed/8kMaTybvDUw&#34; &#xA;      allowfullscreen &#xA;      title=&#34;YouTube Video&#34;&#xA;      loading=&#34;lazy&#34;&#xA;    &gt;&lt;/iframe&gt;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;style&gt;&#xA;.media-embed {&#xA;  max-width: 100%;&#xA;  margin: 1rem 0;&#xA;}&#xA;&#xA;.video-container {&#xA;  position: relative;&#xA;  padding-bottom: 56.25%;&#xA;  height: 0;&#xA;  overflow: hidden;&#xA;}&#xA;&#xA;.video-container iframe {&#xA;  position: absolute;&#xA;  top: 0;&#xA;  left: 0;&#xA;  width: 100%;&#xA;  height: 100%;&#xA;  border: 0;&#xA;  border-radius: 12px;&#xA;}&#xA;&lt;/style&gt;&#xA;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;「誰建過 Agent？」台下一片手海。「誰建過十個以上的 Agent？」手少了一些。「誰建過一百個 Agent？」剩下幾隻手。Dex Horthy 站在 AI Engineer 大會的講台上，看著這些手，知道他們都經歷過同樣的事。&lt;/p&gt;&#xA;&lt;p&gt;他自己也經歷過。第一次嘗試做 DevOps Agent 時，他給了 Agent 一個 Makefile，說「你可以執行 make 指令，去把專案建起來」。結果 Agent 把順序全搞錯了。Dex 花了兩小時不斷修改 Prompt，加入越來越多細節，最後寫出了精確的執行步驟。然後他意識到：「我用 90 秒就能寫出這個 bash script。」不是每個問題都需要 Agent。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AI 時代該學什麼？OpenAI Codex 負責人的三個建議</title>
      <link>https://bnextmedia.github.io/AINEXT/posts/20251224-openai-career-advice-ai-era/</link>
      <pubDate>Wed, 24 Dec 2025 01:28:00 +0800</pubDate>
      <guid>https://bnextmedia.github.io/AINEXT/posts/20251224-openai-career-advice-ai-era/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本文整理自 Lenny&amp;rsquo;s Podcast 2024 年 12 月播出的單集，主持人 Lenny Rachitsky 專訪 OpenAI Codex 產品負責人 Alexander Embiricos。&#xA;收聽連結：&lt;a href=&#34;https://www.youtube.com/watch?v=z1ISq9Ty4Cg&#34;&gt;YouTube&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;這個問題越來越難回答&#34;&gt;這個問題越來越難回答&lt;/h2&gt;&#xA;&lt;p&gt;「AI 寫程式越來越強，我還該學 coding 嗎？」&lt;/p&gt;&#xA;&lt;p&gt;這問題現在幾乎每個考慮進科技業的人都會問，每個在科技業工作的人也在想。Alexander Embiricos 是 OpenAI Codex 的產品負責人——他的工作就是讓 AI 更會寫程式。如果有人知道答案，應該是他。&lt;/p&gt;&#xA;&lt;p&gt;他在訪談中給了三個建議。這些建議不是那種「學會 prompt engineering」的淺層答案，而是更根本的方向性思考。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;第一成為做事的人&#34;&gt;第一：成為做事的人&lt;/h2&gt;&#xA;&lt;p&gt;Embiricos 的第一個建議是：成為一個「做事的人」（be a doer）。&lt;/p&gt;&#xA;&lt;p&gt;這聽起來像廢話，但他的意思很具體。他說，有了 coding agent 之後，即使是大學生或剛畢業的人，能做到的事情比以前多非常多。工具的進步意味著一個人的產出上限被大幅提高。這個變化是實實在在的，不是理論上的。&lt;/p&gt;&#xA;&lt;p&gt;他在招募早期職涯的人時，會特別看一件事：這個人用最新的工具有多 productive？如果你是新手，你用 Codex、Cursor 這些工具的熟練度，應該要很高。因為這些工具正是用來彌補經驗不足的。&lt;/p&gt;&#xA;&lt;p&gt;有趣的是，他認為這反而縮小了資深和資淺之間的差距。以前資深工程師的優勢是多年累積的經驗和直覺，需要時間才能獲得。但現在，很多「經驗」的價值可以被 AI 工具部分取代。資淺的人善用工具，可以更快接近資深的產出水準。&lt;/p&gt;&#xA;&lt;p&gt;但這也意味著：如果你不用這些工具，你的劣勢會更明顯。以前資淺的人可以說「我還在學」，慢慢累積經驗。現在，如果你的同儕用 AI 工具做出了你做不到的東西，那個差距是立刻可見的。&lt;/p&gt;&#xA;&lt;p&gt;他的建議是：不要只是完成學校的作業或公司指派的任務。去做一些真正的專案，用最新的工具，看看你能做到什麼程度。那個「做到什麼程度」的答案，會隨著工具進步而持續提高。你要持續追著那個前沿跑。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;第二系統工程和協作能力依然重要&#34;&gt;第二：系統工程和協作能力依然重要&lt;/h2&gt;&#xA;&lt;p&gt;第二個建議可能會讓一些人鬆一口氣：傳統的工程能力並沒有過時。&lt;/p&gt;&#xA;&lt;p&gt;Embiricos 說，理解「什麼讓一個軟體系統變得好」這件事，在相當長的時間內還是很重要。這包括系統架構、可維護性、可擴展性、安全性——這些不是 AI 短期內可以完全取代的判斷。&lt;/p&gt;&#xA;&lt;p&gt;他舉了一個例子。一個在 Atlas 專案（OpenAI 的瀏覽器）工作的工程師，發現 Codex 沒辦法自己驗證它寫的程式碼是不是正確。於是他提示 Codex：「為什麼你不能驗證你的工作？去修好它。」然後讓這個過程循環跑。這是一個需要人類判斷的介入——知道問題在哪裡、知道怎麼用 AI 來解決這個問題、知道什麼時候該介入和怎麼介入。&lt;/p&gt;&#xA;&lt;p&gt;這種「在各個階段引導 AI 做正確的事」的能力，需要你對整個系統有理解。你不需要自己寫每一行 for loop，但你需要知道這個系統應該長什麼樣子、有什麼潛在的問題、怎麼驗證它是對的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AI 寫程式超快，但你跟得上嗎？Netflix 的三階段解法</title>
      <link>https://bnextmedia.github.io/AINEXT/posts/20251222-netflix-ai-software-crisis/</link>
      <pubDate>Mon, 22 Dec 2025 22:33:00 +0800</pubDate>
      <guid>https://bnextmedia.github.io/AINEXT/posts/20251222-netflix-ai-software-crisis/</guid>
      <description>&lt;p&gt;「我部署過我不完全理解的程式碼。我生成了它、測試了它、部署了它。但我無法解釋它是怎麼運作的。」&lt;/p&gt;&#xA;&lt;p&gt;這是 Netflix 工程師 Jake Nations 在一場技術演講中的開場白。台下一片安靜，接著他補了一句：「我願意打賭，你們每一個人也都做過。」掌聲響起。&lt;/p&gt;&#xA;&lt;p&gt;Jake 過去幾年在 Netflix 負責推動 AI 工具的採用。他親眼見證 AI 帶來的加速——過去需要好幾天才能完成的工作，現在幾小時就能搞定；擱置多年的大型程式碼重構，終於有人手去執行。但他也注意到一件令人不安的事：程式碼生成的速度，已經超過工程師理解的速度。&lt;/p&gt;&#xA;&lt;p&gt;大型系統總是會在意想不到的地方掛掉。當那一刻來臨，你最好搞得懂自己正在除錯的程式碼。問題是，AI 一秒鐘能產出上千行程式碼，我們的理解力根本追不上。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/eIoohUmYpGI&#34;&gt;嵌入影片&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;軟體危機簡史這不是第一次&#34;&gt;軟體危機簡史：這不是第一次&lt;/h2&gt;&#xA;&lt;p&gt;Jake 說，這種「複雜性超出管理能力」的困境，其實不是什麼新鮮事。每一代軟體工程師都碰過這堵牆。&lt;/p&gt;&#xA;&lt;p&gt;1960 年代末，一群聰明的電腦科學家聚在一起，發現了一個問題：社會對軟體的需求暴增，但軟體開發的速度根本跟不上。專案延遲、成本超支、品質低落。他們把這個現象稱為「軟體危機」。&lt;/p&gt;&#xA;&lt;p&gt;荷蘭電腦科學家 Edsger Dijkstra 當時說過一句話：「當我們只有幾台弱小的電腦時，程式設計只是個小問題；現在我們有了巨大的電腦，程式設計也變成了巨大的問題。」他的觀察是：硬體能力每成長一千倍，社會對軟體的期待也會跟著漲一千倍，留給工程師的只有如何在「想要」和「做得到」之間找到平衡。&lt;/p&gt;&#xA;&lt;p&gt;這種循環不斷重演。1970 年代有了 C 語言，可以寫更大的系統。1980 年代個人電腦普及，人人都能寫程式。1990 年代物件導向程式設計流行，帶來了複雜到讓人頭痛的繼承結構。2000 年代敏捷開發興起。2010 年代雲端、行動裝置、DevOps 全面爆發，軟體真的「吃掉了世界」。&lt;/p&gt;&#xA;&lt;p&gt;而現在，我們有了 AI。Copilot、Cursor、Claude、Codex、Gemini——我們可以用描述的速度生成程式碼。模式依然在重複，但這次的規模是「無限」的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;easy-vs-simpleai-時代最危險的混淆&#34;&gt;Easy vs Simple：AI 時代最危險的混淆&lt;/h2&gt;&#xA;&lt;p&gt;「我們陷入了一個陷阱，」Jake 說，「我們混淆了『容易』和『簡單』。」&lt;/p&gt;&#xA;&lt;p&gt;這兩個詞聽起來很像，但它們指向完全不同的東西。Clojure 程式語言的創造者 Rich Hickey 在 2011 年有一場著名的演講叫做「Simple Made Easy」，對這兩個概念做了精確的區分。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Simple（簡單）&lt;/strong&gt; 的字源來自拉丁文，意思是「一個折疊、一個編織」，也就是沒有糾纏。一個簡單的系統，每個部件各司其職，彼此不會糾纏在一起。你改動一個地方，不會牽動其他十個地方。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Easy（容易）&lt;/strong&gt; 的字源則是「鄰近」。什麼東西離你近、伸手就能拿到，那就是容易的。安裝一個套件、從 Stack Overflow 複製一段程式碼、讓 AI 生成一個功能——這些都是「容易」的事。&lt;/p&gt;&#xA;&lt;p&gt;重點來了：&lt;strong&gt;你沒辦法靠許願讓事情變簡單&lt;/strong&gt;。簡單需要思考、需要設計、需要花力氣把糾纏的東西理清楚。但你隨時都可以讓事情變得更容易——只要把它放得更近就好。&lt;/p&gt;&#xA;&lt;p&gt;人類天生會走阻力最小的路，這是生存本能，沒什麼好怪的。在 AI 出現之前，這種取捨還算可控——複雜性在程式碼庫中累積的速度夠慢，工程師有時間重構、重新思考、必要時砍掉重練。&lt;/p&gt;&#xA;&lt;p&gt;但 Jake 認為 AI 打破了這個平衡。AI 是終極的「容易製造機」，讓容易的路變得毫無阻力，以至於我們根本不再考慮簡單的那條路。程式碼瞬間就能出現，誰還會停下來想架構？&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
